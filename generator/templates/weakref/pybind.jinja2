{% set pybind_class = 'class_' + bw_class.lower() %}
{% set py_class = '_' + bw_class %}
py::class_&lt;PyBinding::{{ weakref_class }}&gt; {{ pybind_class }}(m, "{{ py_class }}");
{{ pybind_class }}.def("__init__", [](PyBinding::{{ weakref_class }}){
  throw std::runtime_error("{{ py_class }} objects can't be instantiated from python side");
});
{% for mdef in module_defs
 %}{{ pybind_class }}.{{ mdef.type }}("{{ mdef.trans_name }}", {%
  if mdef.sign
  %}({{ mdef.sign.rtype }} (PyBinding::{{ weakref_class }}::*)({{ mdef.sign.args }})) {%
  endif
  %}&amp;PyBinding::{{ weakref_class }}::{{ mdef.method_name }});
{% endfor %}


{% if enums %}
{% set pybind_submodule = 'enum_' + bw_class.lower() %}
py::module {{ pybind_submodule }} = m.def_submodule("{{ bw_class }}");
{% for e in enums
 %}{{ pybind_submodule }}.attr("{{ e }}") = py::cast({{ enum_namespace }}::{{ e }});
{% endfor %}
{% endif %}
